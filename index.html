<!DOCTYPE html>
<html lang="pt-BR" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
  />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>TremorPSD - Análise Aprimorada</title>

  <!-- Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Chart.js via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- jsPDF via CDN for PDF Export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <!-- Custom Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
    rel="stylesheet"
  />

  <style>
    /* Estilos base e customizações */
    body {
      font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial,
        sans-serif;
      -webkit-tap-highlight-color: transparent;
    }
    /* Animação de pulso para o ícone */
    @keyframes pulse-glow {
      0%,
      100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
      }
      50% {
        transform: scale(1.05);
        box-shadow: 0 0 20px 10px rgba(59, 130, 246, 0);
      }
    }
    .pulse-glow-animation {
      animation: pulse-glow 2s infinite cubic-bezier(0.4, 0, 0.6, 1);
    }
    /* Custom scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #1f2937; /* bg-gray-800 */
    }
    ::-webkit-scrollbar-thumb {
      background: #4b5563; /* bg-gray-600 */
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #6b7280; /* bg-gray-500 */
    }
     /* Toast Notification */
    #toast {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 12px 24px;
        border-radius: 9999px;
        color: white;
        font-weight: 500;
        z-index: 100;
        opacity: 0;
        transition: opacity 0.3s, top 0.3s;
        pointer-events: none;
    }
    #toast.show {
        opacity: 1;
        top: 40px;
    }
    #toast.success { background-color: #10B981; } /* emerald-500 */
    #toast.error { background-color: #EF4444; } /* red-500 */
    #toast.info { background-color: #3B82F6; } /* blue-500 */
  </style>
</head>
<body class="bg-gray-900 text-white antialiased min-h-screen">
  <div id="toast"></div>
  <!-- Onboarding Screen -->
  <div
    id="onboarding"
    class="fixed inset-0 bg-gradient-to-br from-indigo-600 to-purple-700 flex flex-col justify-center items-center p-6 z-50 transition-opacity duration-500"
  >
    <div class="bg-white/20 backdrop-blur-lg p-6 rounded-3xl mb-8">
      <svg
        class="w-16 h-16 text-white"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
        xmlns="http://www.w3.org/2000/svg"
        ><path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M13 10V3L4 14h7v7l9-11h-7z"
        ></path></svg
      >
    </div>
    <h1 class="text-4xl font-bold mb-4 text-center">Bem-vindo ao TremorPSD</h1>
    <p class="text-lg text-white/80 text-center max-w-sm mb-10">
      Analise tremores de forma precisa usando os sensores do seu dispositivo ou importando um arquivo TXT/CSV.
    </p>
    <button
      onclick="startOnboarding()"
      class="bg-white text-indigo-600 font-semibold text-lg py-4 px-12 rounded-full shadow-2xl transform hover:scale-105 active:scale-95 transition-transform duration-200"
    >
      Começar Análise
    </button>
  </div>

  <!-- Main App Container -->
  <div id="app" class="opacity-0 transition-opacity duration-500">
    <header
      class="bg-gray-900/70 backdrop-blur-lg sticky top-0 z-40 border-b border-gray-700/50 p-4"
    >
      <div class="max-w-4xl mx-auto">
        <h1 class="text-xl font-bold">TremorPSD</h1>
        <p class="text-sm text-gray-400">Análise de Tremor por Densidade Espectral de Potência</p>
      </div>
    </header>

    <main class="p-4 max-w-4xl mx-auto pb-24">
      <!-- Status & Control Section -->
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
        <!-- Status Card -->
        <div
          id="statusCard"
          class="bg-gray-800 rounded-2xl p-6 border-t-4 border-blue-500 transition-all duration-300"
        >
          <div class="flex items-center space-x-4">
            <div
              id="statusIconContainer"
              class="w-16 h-16 bg-gray-700 rounded-full flex items-center justify-center flex-shrink-0"
            >
              <div
                id="spinner"
                class="w-8 h-8 border-4 border-gray-600 border-t-blue-500 rounded-full animate-spin"
              ></div>
              <svg
                id="iconReady"
                class="hidden w-10 h-10 text-green-400"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
                ><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg
              >
               <svg id="iconError" class="hidden w-10 h-10 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            </div>
            <div>
              <p id="statusText" class="text-lg font-semibold">Preparando sensores...</p>
              <p id="statusDetail" class="text-sm text-gray-400">Aguarde a inicialização</p>
            </div>
          </div>
        </div>

        <!-- Control Panel -->
        <div id="controlPanel" class="bg-gray-800 rounded-2xl p-6">
          <div class="grid grid-cols-2 gap-4 mb-4">
            <div>
              <label for="duration" class="text-sm text-gray-400 block mb-1">Duração (s)</label>
              <input
                type="number"
                id="duration"
                value="20"
                min="5"
                max="60"
                class="w-full bg-gray-700 text-white rounded-lg p-2 border border-gray-600 focus:ring-2 focus:ring-blue-500 focus:outline-none"
              />
            </div>
            <div>
              <label for="axis" class="text-sm text-gray-400 block mb-1">Eixo do Sinal</label>
              <select
                id="axis"
                class="w-full bg-gray-700 text-white rounded-lg p-2 border border-gray-600 focus:ring-2 focus:ring-blue-500 focus:outline-none"
              >
                <option value="mag">Magnitude</option>
                <option value="x">Eixo X</option>
                <option value="y">Eixo Y</option>
                <option value="z">Eixo Z</option>
              </select>
            </div>
          </div>

          <!-- Fonte dos Dados -->
          <div class="col-span-2 grid grid-cols-2 gap-4 mb-2">
            <div>
              <label for="source" class="text-sm text-gray-400 block mb-1">Fonte dos dados</label>
              <select
                id="source"
                onchange="handleSourceChange(this.value)"
                class="w-full bg-gray-700 text-white rounded-lg p-2 border border-gray-600 focus:ring-2 focus:ring-blue-500 focus:outline-none"
              >
                <option value="sensor" selected>Acelerômetro do dispositivo</option>
                <option value="file">Arquivo externo (TXT/CSV)</option>
              </select>
            </div>
            <div>
              <label for="importFs" class="text-sm text-gray-400 block mb-1">Taxa de amostragem (Hz)</label>
              <input
                type="number"
                id="importFs"
                value="100"
                min="1"
                step="1"
                class="w-full bg-gray-700 text-white rounded-lg p-2 border border-gray-600 focus:ring-2 focus:ring-blue-500 focus:outline-none disabled:opacity-50"
                disabled
              />
              <p id="detectedFs" class="text-xs text-gray-400 mt-1">Detectado (sensor): —</p>
            </div>
          </div>

          <!-- Importação de Arquivo -->
          <div
            id="fileImportPanel"
            class="hidden col-span-2 bg-gray-800/80 rounded-xl p-3 border border-gray-700"
          >
            <div class="grid grid-cols-1 md:grid-cols-3 gap-3 items-end">
              <div class="md:col-span-2">
                <label class="text-sm text-gray-400 block mb-1">Selecione o arquivo (TXT/CSV)</label>
                <input
                  id="fileInput"
                  type="file"
                  accept=".txt,.csv"
                  class="w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-white hover:file:bg-blue-600"
                />
                <label class="inline-flex items-center gap-2 mt-2 text-sm text-gray-300">
                  <input id="useFsFile" type="checkbox" class="accent-blue-500" checked />
                  Usar Fs do arquivo quando disponível
                </label>
              </div>
              <div class="flex gap-2">
                <button
                  onclick="importFile()"
                  class="flex-1 bg-emerald-600 hover:bg-emerald-700 text-white font-semibold py-2 rounded-lg"
                >
                  Carregar
                </button>
                <button
                  onclick="clearImported()"
                  class="px-3 bg-gray-700 hover:bg-gray-600 text-white font-semibold rounded-lg"
                >
                  Limpar
                </button>
              </div>
            </div>
            <p id="fileInfo" class="text-xs text-gray-400 mt-2">Nenhum arquivo carregado.</p>
          </div>

          <button
            id="actionBtn"
            onclick="handleAction()"
            disabled
            class="w-full bg-blue-600 text-white font-semibold py-3 rounded-lg transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed hover:bg-blue-700 active:bg-blue-800 relative overflow-hidden mt-4"
          >
            <span id="actionText">Aguardando Sensores</span>
            <div id="progressBar" class="absolute bottom-0 left-0 h-1 bg-white/30" style="width: 0%"></div>
          </button>
        </div>
      </div>

      <!-- Results Section (Initially Hidden) -->
      <div id="resultsSection" class="hidden">
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-2xl font-bold">Resultados da Análise</h2>
          <button
            onclick="showInfoModal()"
            class="text-blue-400 hover:text-blue-300 flex items-center space-x-1"
          >
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"
              ><path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              ></path></svg
            >
            <span>O que isso significa?</span>
          </button>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
          <!-- Metrics Grid -->
          <div class="bg-gray-800 rounded-2xl p-6">
            <h3 class="font-semibold mb-4 text-lg">Métricas de Análise</h3>
            <div class="grid grid-cols-2 sm:grid-cols-3 gap-4">
              <div class="bg-gray-700/50 p-3 rounded-lg">
                <p class="text-xs text-gray-400 truncate" title="Frequência de Pico (Peak Frequency)">
                  Freq. de Pico
                </p>
                <p id="metricPeakFreq" class="text-xl font-bold text-blue-400">— Hz</p>
              </div>
              <div class="bg-gray-700/50 p-3 rounded-lg">
                <p class="text-xs text-gray-400" title="Potência Espectral Total">Potência Total</p>
                <p id="metricTotalPower" class="text-xl font-bold text-teal-400">—</p>
              </div>
              <div class="bg-gray-700/50 p-3 rounded-lg">
                <p class="text-xs text-gray-400" title="Proeminência do Pico">Proeminência</p>
                <p id="metricProminence" class="text-xl font-bold text-cyan-400">—</p>
              </div>
              <div class="bg-gray-700/50 p-3 rounded-lg">
                <p class="text-xs text-gray-400" title="Largura à Meia Altura (Full Width at Half Maximum)">
                  FWHM
                </p>
                <p id="metricFWHM" class="text-xl font-bold text-yellow-400">— Hz</p>
              </div>
              <div class="bg-gray-700/50 p-3 rounded-lg">
                <p class="text-xs text-gray-400" title="Índice de Estabilidade do Tremor (Tremor Stability Index)">
                  Estabilidade (TSI)
                </p>
                <p id="metricTSI" class="text-xl font-bold text-purple-400">—</p>
              </div>
              <div class="bg-gray-700/50 p-3 rounded-lg">
                <p class="text-xs text-gray-400" title="Entropia Espectral (Spectral Entropy)">
                  Entropia Esp.
                </p>
                <p id="metricEntropy" class="text-xl font-bold text-pink-400">—</p>
              </div>
              <div class="bg-gray-700/50 p-3 rounded-lg">
                <p class="text-xs text-gray-400" title="Valor Quadrático Médio (Root Mean Square)">
                  Amplitude (RMS)
                </p>
                <p id="metricRMS" class="text-xl font-bold text-lime-400">—</p>
              </div>
              <div class="bg-gray-700/50 p-3 rounded-lg">
                <p class="text-xs text-gray-400" title="Mediana do Jerk (50º percentil)">Jerk (JR50)</p>
                <p id="metricJR50" class="text-xl font-bold text-red-400">—</p>
              </div>
              <div class="bg-gray-700/50 p-3 rounded-lg">
                <p class="text-xs text-gray-400" title="Índice de Energia Wavelet">Índice Wavelet</p>
                <p id="metricWavelet" class="text-xl font-bold text-indigo-400">—</p>
              </div>
            </div>
          </div>
          <!-- Classification -->
          <div class="bg-gray-800 rounded-2xl p-6">
            <h3 class="font-semibold mb-4 text-lg">Classificação Sugerida</h3>
            <div class="space-y-4" id="classificationContainer">
              <!-- Items inserted by JS -->
            </div>
          </div>
        </div>

        <!-- Charts Section -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <div class="bg-gray-800 rounded-2xl p-4 min-h-[256px]">
            <h3 class="font-semibold mb-2 text-center text-gray-300">Sinal no Tempo</h3>
            <canvas id="chartTime"></canvas>
          </div>
          <div class="bg-gray-800 rounded-2xl p-4 min-h-[256px]">
            <h3 class="font-semibold mb-2 text-center text-gray-300">
              Densidade Espectral de Potência (PSD)
            </h3>
            <canvas id="chartPSD"></canvas>
          </div>
        </div>
      </div>
    </main>

    <!-- Footer Actions -->
    <footer
      id="footerActions"
      class="hidden fixed bottom-0 left-0 right-0 bg-gray-800/80 backdrop-blur-lg border-t border-gray-700 p-2 md:p-4"
    >
      <div class="max-w-4xl mx-auto grid grid-cols-4 gap-2 md:gap-4">
        <button
          onclick="exportPdf()"
          class="w-full bg-red-600 text-white font-semibold py-2 md:py-3 rounded-lg hover:bg-red-700 transition-colors text-xs md:text-base"
        >
          Exportar PDF
        </button>
        <button
          onclick="exportMetricsCsv()"
          class="w-full bg-green-600 text-white font-semibold py-2 md:py-3 rounded-lg hover:bg-green-700 transition-colors text-xs md:text-base"
        >
          Métricas (CSV)
        </button>
        <button
          onclick="exportRawCsv()"
          class="w-full bg-gray-600 text-white font-semibold py-2 md:py-3 rounded-lg hover:bg-gray-700 transition-colors text-xs md:text-base"
        >
          Dados (CSV)
        </button>
        <button
          onclick="resetApp()"
          class="w-full bg-blue-600 text-white font-semibold py-2 md:py-3 rounded-lg hover:bg-blue-700 transition-colors text-xs md:text-base"
        >
          Nova Análise
        </button>
      </div>
    </footer>
  </div>

  <!-- Info Modal -->
    <div id="infoModal" class="fixed inset-0 bg-black/70 flex items-center justify-center p-4 z-50 hidden" onclick="hideInfoModal(event)">
        <div class="bg-gray-800 rounded-2xl max-w-2xl w-full max-h-[80vh] overflow-y-auto p-6" onclick="event.stopPropagation()">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">Entendendo os Resultados</h2>
                <button onclick="hideInfoModal()" class="text-gray-400 hover:text-white text-2xl leading-none">&times;</button>
            </div>
            <div class="prose prose-invert prose-sm md:prose-base text-gray-300 space-y-4">
                <p>Esta análise transforma o sinal do acelerômetro (tremor) em um gráfico de <strong>Densidade Espectral de Potência (PSD)</strong>, que mostra quais frequências são mais intensas.</p>
                
                <div>
                    <h4 class="font-semibold text-white">Frequência de Pico (Hz)</h4>
                    <p>A frequência onde o tremor é mais forte. É o principal indicador para classificar o tipo de tremor.</p>
                </div>
                <div>
                    <h4 class="font-semibold text-white">Amplitude (RMS)</h4>
                    <p>Mede a intensidade ou amplitude efetiva do tremor. Um valor mais alto indica um tremor de maior amplitude.</p>
                </div>
                <div>
                    <h4 class="font-semibold text-white">Potência Total & Proeminência</h4>
                    <p><b>Potência Total</b> é a energia total do sinal de tremor. <b>Proeminência</b> mede o quão claro e distinto é o pico principal de tremor em relação ao ruído de fundo.</p>
                </div>
                <div>
                    <h4 class="font-semibold text-white">FWHM & Estabilidade (TSI)</h4>
                    <p>Medem a regularidade do tremor. Valores baixos (pico fino) significam um tremor muito rítmico e estável.</p>
                </div>
                 <div>
                    <h4 class="font-semibold text-white">Jerk (JR50)</h4>
                    <p>Mede a "brusquidão" do movimento. Valores altos são característicos de movimentos irregulares e súbitos, como mioclonias.</p>
                </div>
                <div>
                    <h4 class="font-semibold text-white">Índice Wavelet & Entropia</h4>
                    <p>O <b>Índice Wavelet</b> avalia a consistência do tremor na sua frequência principal ao longo do tempo. <b>Entropia</b> mede a complexidade do sinal (sinais puros têm baixa entropia).</p>
                </div>
                <div>
                    <h4 class="font-semibold text-white">Classificação Sugerida</h4>
                    <p>Com base nas características encontradas, o sistema oferece uma sugestão. <strong>Isto não é um diagnóstico</strong> e deve ser interpretado por um profissional de saúde qualificado.</p>
                </div>
                <p class="text-xs text-gray-500 pt-4 border-t border-gray-700">A análise é feita usando o Método de Welch para calcular a PSD, uma técnica robusta para análise de sinais biológicos.</p>
            </div>
        </div>
    </div>

  <script>
    // --- DOM Elements ---
    const dom = {
      onboarding: document.getElementById('onboarding'),
      app: document.getElementById('app'),
      toast: document.getElementById('toast'),
      statusText: document.getElementById('statusText'),
      statusDetail: document.getElementById('statusDetail'),
      spinner: document.getElementById('spinner'),
      iconReady: document.getElementById('iconReady'),
      iconError: document.getElementById('iconError'),
      actionBtn: document.getElementById('actionBtn'),
      actionText: document.getElementById('actionText'),
      progressBar: document.getElementById('progressBar'),
      durationInput: document.getElementById('duration'),
      axisSelect: document.getElementById('axis'),
      sourceSelect: document.getElementById('source'),
      importFsInput: document.getElementById('importFs'),
      detectedFsText: document.getElementById('detectedFs'),
      fileImportPanel: document.getElementById('fileImportPanel'),
      fileInput: document.getElementById('fileInput'),
      fileInfo: document.getElementById('fileInfo'),
      useFsFileCheckbox: document.getElementById('useFsFile'),
      resultsSection: document.getElementById('resultsSection'),
      footerActions: document.getElementById('footerActions'),
      controlPanel: document.getElementById('controlPanel'),
      // Metrics
      metricPeakFreq: document.getElementById('metricPeakFreq'),
      metricTotalPower: document.getElementById('metricTotalPower'),
      metricProminence: document.getElementById('metricProminence'),
      metricFWHM: document.getElementById('metricFWHM'),
      metricTSI: document.getElementById('metricTSI'),
      metricEntropy: document.getElementById('metricEntropy'),
      metricRMS: document.getElementById('metricRMS'),
      metricJR50: document.getElementById('metricJR50'),
      metricWavelet: document.getElementById('metricWavelet'),
      // Classification
      classificationContainer: document.getElementById('classificationContainer'),
      // Modals
      infoModal: document.getElementById('infoModal'),
    };

    // --- State ---
    let state = {
      isReady: false,
      isCollecting: false,
      isAnalyzing: false,
      sensor: null,
      sensorData: [],
      importedData: null,
      analysisResult: null,
      sensorFs: 0,
      charts: {
        time: null,
        psd: null,
      },
      collectionInterval: null,
      startTime: 0,
    };
    
    const CLASSIFICATION_TYPES = {
      OT: { label: "Ortostático", color: "#FBBF24" }, // amber-400
      ET: { label: "Essencial", color: "#34D399" }, // emerald-400
      DT: { label: "Distônico", color: "#F87171" }, // red-400
      MY: { label: "Mioclonia", color: "#60A5FA" } // blue-400
    };

    // --- Initialization ---
    function startOnboarding() {
      dom.onboarding.classList.add('opacity-0', 'pointer-events-none');
      dom.app.classList.remove('opacity-0');
      setTimeout(initApp, 500);
    }

    async function initApp() {
        try {
            if ('Accelerometer' in window) {
                // Try modern API first
                const sensor = new Accelerometer({ frequency: 100 });
                // The permission prompt is implicit here
                sensor.onreading = () => { 
                    state.sensorFs = sensor.frequency;
                    sensor.stop();
                    state.sensor = sensor;
                    updateStatus('ready');
                    sensor.onreading = null; // one-time setup
                };
                sensor.onerror = (event) => {
                     // If it fails (e.g., security error), try fallback
                    if (event.error.name === 'NotAllowedError') {
                        throw event.error;
                    }
                    console.warn('Modern sensor API failed, trying fallback.', event.error.message);
                    initFallbackSensor();
                };
                sensor.start();
            } else {
                initFallbackSensor();
            }
        } catch (error) {
            console.error('Sensor Error:', error);
            if(error.name === 'NotAllowedError') {
                 updateStatus('error', 'Permissão para sensor negada.');
            } else {
                 updateStatus('error', 'Falha ao iniciar o sensor.');
            }
        }
    }
    
    async function initFallbackSensor() {
        if ('DeviceMotionEvent' in window && typeof DeviceMotionEvent.requestPermission === 'function') {
            const permission = await DeviceMotionEvent.requestPermission();
            if (permission === 'granted') {
                 state.sensor = null; // Mark that we are using fallback
                 updateStatus('ready', 'Dispositivo legado. Fs será estimado.');
            } else {
                throw new Error('NotAllowedError');
            }
        } else if ('DeviceMotionEvent' in window) {
            // For Android or devices that don't need permission
             state.sensor = null;
             updateStatus('ready', 'Dispositivo legado. Fs será estimado.');
        } else {
            updateStatus('error', 'Nenhum sensor de movimento encontrado.');
        }
    }
    
    // --- UI Update Functions ---
    function updateStatus(status, detail = '') {
        dom.spinner.classList.add('hidden');
        dom.iconReady.classList.add('hidden');
        dom.iconError.classList.add('hidden');
        dom.actionBtn.disabled = true;

        switch (status) {
            case 'ready':
                state.isReady = true;
                dom.iconReady.classList.remove('hidden');
                dom.statusText.textContent = 'Pronto para Análise';
                dom.statusDetail.textContent = detail || 'Clique em iniciar para começar.';
                dom.actionBtn.disabled = false;
                dom.actionText.textContent = 'Iniciar Coleta';
                dom.detectedFsText.textContent = `Detectado (sensor): ~${state.sensorFs || 'N/A'} Hz`;
                break;
            case 'collecting':
                dom.spinner.classList.remove('hidden');
                dom.statusText.textContent = 'Coletando Dados...';
                dom.statusDetail.textContent = 'Mantenha o dispositivo estável.';
                dom.actionText.textContent = 'Coletando...';
                dom.actionBtn.disabled = false;
                toggleControls(false);
                break;
            case 'analyzing':
                dom.spinner.classList.remove('hidden');
                dom.statusText.textContent = 'Analisando...';
                dom.statusDetail.textContent = 'Processando os dados coletados.';
                dom.actionText.textContent = 'Analisando...';
                break;
            case 'error':
                 state.isReady = false;
                 dom.iconError.classList.remove('hidden');
                 dom.statusText.textContent = 'Erro';
                 dom.statusDetail.textContent = detail;
                 dom.actionText.textContent = 'Sensor Indisponível';
                 handleSourceChange('file');
                 dom.sourceSelect.value = 'file';
                 if(dom.sourceSelect.options[0]) dom.sourceSelect.options[0].disabled = true;
                 break;
        }
    }
    
    function toggleControls(enable) {
        const elements = [dom.durationInput, dom.axisSelect, dom.sourceSelect, dom.importFsInput, dom.fileInput];
        elements.forEach(el => el.disabled = !enable);
        if(dom.sourceSelect.value === 'file') {
            document.querySelector('#fileImportPanel button').disabled = !enable;
            document.querySelectorAll('#fileImportPanel button')[1].disabled = !enable;
        }
    }
    
    function showToast(message, type = 'info') {
        dom.toast.textContent = message;
        dom.toast.className = ``; // Reset
        dom.toast.classList.add('show', type);
        setTimeout(() => {
            dom.toast.classList.remove('show');
        }, 3000);
    }

    // --- Main Actions ---
    function handleAction() {
        if (!state.isReady && dom.sourceSelect.value === 'sensor') return;
        
        if (state.isCollecting) {
            stopCollection();
        } else if (dom.sourceSelect.value === 'sensor') {
            startCollection();
        } else if (dom.sourceSelect.value === 'file') {
            if(state.importedData) {
                analyzeData(state.importedData.data, state.importedData.fs);
            } else {
                showToast('Por favor, carregue um arquivo primeiro.', 'error');
            }
        }
    }

    function startCollection() {
        if (state.isCollecting) return;
        
        resetResults();
        state.isCollecting = true;
        state.sensorData = [];
        state.startTime = Date.now();
        const duration = parseInt(dom.durationInput.value, 10) * 1000;

        if(state.sensor) { // Modern API
            state.sensor.onreading = () => {
                state.sensorData.push({
                    t: state.sensor.timestamp,
                    x: state.sensor.x,
                    y: state.sensor.y,
                    z: state.sensor.z,
                });
            };
            state.sensor.start();
        } else { // Fallback API
            window.addEventListener('devicemotion', handleDeviceMotion, { passive: true });
        }

        updateStatus('collecting');

        state.collectionInterval = setInterval(() => {
            const elapsedTime = Date.now() - state.startTime;
            const progress = (elapsedTime / duration) * 100;
            dom.progressBar.style.width = `${Math.min(progress, 100)}%`;

            if (elapsedTime >= duration) {
                stopCollection();
            }
        }, 100);
    }
    
    function handleDeviceMotion(event) {
         state.sensorData.push({
            t: event.timeStamp,
            x: event.accelerationIncludingGravity.x,
            y: event.accelerationIncludingGravity.y,
            z: event.accelerationIncludingGravity.z,
        });
    }

    function stopCollection() {
        clearInterval(state.collectionInterval);
        state.isCollecting = false;
        
        if (state.sensor) {
            state.sensor.stop();
        } else {
            window.removeEventListener('devicemotion', handleDeviceMotion);
        }

        dom.progressBar.style.width = '0%';
        toggleControls(true);
        updateStatus('analyzing');

        let fs = state.sensorFs;
        if (!fs && state.sensorData.length > 1) {
            const totalTime = (state.sensorData[state.sensorData.length - 1].t - state.sensorData[0].t) / 1000;
            fs = Math.round(state.sensorData.length / totalTime);
            dom.detectedFsText.textContent = `Estimado (sensor): ~${fs} Hz`;
        }

        setTimeout(() => analyzeData(state.sensorData, fs), 100);
    }
    
    // --- File Handling ---
    function handleSourceChange(source) {
        if (source === 'file') {
            dom.fileImportPanel.classList.remove('hidden');
            dom.importFsInput.disabled = false;
            dom.actionText.textContent = state.importedData ? 'Analisar Arquivo' : 'Carregue um Arquivo';
            dom.actionBtn.disabled = !state.importedData;
        } else {
            dom.fileImportPanel.classList.add('hidden');
            dom.importFsInput.disabled = true;
            dom.actionText.textContent = 'Iniciar Coleta';
            dom.actionBtn.disabled = !state.isReady;
        }
    }

    function importFile() {
        const file = dom.fileInput.files[0];
        if (!file) {
            showToast('Nenhum arquivo selecionado.', 'error');
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            const content = e.target.result;
            try {
                const parsed = parseSignalFile(content);
                state.importedData = parsed;

                let finalFs = parseInt(dom.importFsInput.value, 10) || 100;
                if (parsed.fs && dom.useFsFileCheckbox.checked) {
                   finalFs = parsed.fs;
                }
                state.importedData.fs = finalFs;
                dom.importFsInput.value = finalFs;
                
                dom.fileInfo.textContent = `Arquivo "${file.name}" carregado. ${parsed.data.length} amostras. Fs: ${finalFs} Hz.`;
                dom.actionBtn.disabled = false;
                dom.actionText.textContent = 'Analisar Arquivo';
                showToast('Arquivo carregado com sucesso!', 'success');
            } catch (error) {
                showToast(`Erro ao processar o arquivo: ${error.message}`, 'error');
                clearImported();
            }
        };
        reader.readAsText(file);
    }
    
    function parseSignalFile(content) {
        const lines = content.split(/\r?\n/).map(line => line.trim().replace(/"/g, ''));

        let fs = null;
        const channels = { x: [], y: [], z: [] };
        let currentChannel = null;
        let readingData = false;

        for (const line of lines) {
            // Stop reading data when a new channel block starts
            if (line.startsWith('CHANNEL')) {
                readingData = false;
                currentChannel = null;
                continue;
            }

            // Before we start reading data, we look for metadata
            if (!readingData) {
                if (line.toLowerCase().includes('x accel')) {
                    currentChannel = 'x';
                } else if (line.toLowerCase().includes('y accel')) {
                    currentChannel = 'y';
                } else if (line.toLowerCase().includes('z accel')) {
                    currentChannel = 'z';
                } else if (line.startsWith('START')) {
                    const parts = line.split(/\s+/);
                    if (parts.length >= 3) {
                        const dt = parseFloat(parts[2]);
                        if (dt > 0 && !fs) { // Only take the first fs found
                            fs = 1 / dt;
                        }
                        readingData = true; // Data points start on the next line
                    }
                }
                continue;
            }

            // If we are in a data reading state, parse the number
            if (currentChannel) {
                const value = parseFloat(line);
                if (!isNaN(value)) {
                    channels[currentChannel].push(value);
                } else {
                    // If we hit a non-numeric line, this channel's data is done
                    readingData = false;
                    currentChannel = null;
                }
            }
        }

        const foundChannelKeys = Object.keys(channels).filter(key => channels[key].length > 0);

        // If Spike2 parsing yielded no data, fallback to simple CSV parser
        if (foundChannelKeys.length === 0) {
            try {
                // Filter out lines that start with letters, which are likely headers
                const csvLines = content.split('\n').map(l => l.trim()).filter(l => l && !l.match(/^[a-zA-Z]/));
                if (csvLines.length < 10) throw new Error("Dados numéricos insuficientes.");
                
                const data = csvLines.map(line => {
                    const values = line.split(/[,\s\t]+/).map(parseFloat);
                    if (values.some(isNaN)) return null; // Skip non-numeric lines gracefully
                    
                    if (values.length === 1) return { t: 0, x: values[0], y: values[0], z: values[0] };
                    if (values.length === 3) return { t: 0, x: values[0], y: values[1], z: values[2] };
                    if (values.length === 4) return { t: values[0], x: values[1], y: values[2], z: values[3] };
                    return null;
                }).filter(Boolean); // Remove any null entries from failed parses

                if (data.length < 10) throw new Error("Nenhuma linha de dados válida encontrada.");

                 let csvFs = null;
                 const fsMatch = content.match(/#\s*Fs\s*[:=]\s*(\d+\.?\d*)/i);
                 if (fsMatch) csvFs = parseFloat(fsMatch[1]);
                 else if (data.length > 1 && data[0].t !== 0 && data[1].t !== 0) {
                    const timeDiffs = Array.from({length: Math.min(data.length-1, 100)}, (_, i) => data[i+1].t - data[i].t);
                    const avgTimeDiff = timeDiffs.reduce((a, b) => a + b, 0) / timeDiffs.length;
                    if (avgTimeDiff > 0) csvFs = 1 / avgTimeDiff;
                }
                return { data, fs: Math.round(csvFs) || null };

            } catch(e) {
                throw new Error('Formato do arquivo não reconhecido.');
            }
        }
        
        // Combine the parsed Spike2 channels into the final data structure
        const minLength = Math.min(...foundChannelKeys.map(key => channels[key].length));
        const data = [];
        for (let i = 0; i < minLength; i++) {
            const dataPoint = { t: fs ? i / fs : 0 };
            // Assign found channels
            foundChannelKeys.forEach(key => {
                dataPoint[key] = channels[key][i];
            });
            // Fill in missing channels with 0 so magnitude calculation doesn't fail
            if (!dataPoint.hasOwnProperty('x')) dataPoint.x = 0;
            if (!dataPoint.hasOwnProperty('y')) dataPoint.y = 0;
            if (!dataPoint.hasOwnProperty('z')) dataPoint.z = 0;
            data.push(dataPoint);
        }

        return { data, fs };
    }

    function clearImported() {
        state.importedData = null;
        dom.fileInput.value = '';
        dom.fileInfo.textContent = 'Nenhum arquivo carregado.';
        dom.actionBtn.disabled = true;
        dom.actionText.textContent = 'Carregue um Arquivo';
    }

    // --- Signal Processing ---
    function analyzeData(data, fs) {
        if (!data || data.length < 50 || !fs) {
            showToast("Dados insuficientes ou Fs inválida para análise.", 'error');
            updateStatus('ready');
            return;
        }

        const axis = dom.axisSelect.value;
        let signal = data.map(d => {
            if (axis === 'mag') return Math.sqrt(d.x**2 + d.y**2 + d.z**2);
            return d[axis] || 0;
        });
        
        const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
        const detrendedSignal = signal.map(v => v - mean);
        
        const nperseg = Math.pow(2, Math.floor(Math.log2(fs * 2)));
        const { freqs, psd } = welch(detrendedSignal, fs, nperseg);

        state.analysisResult = calculateMetrics(detrendedSignal, psd, freqs, fs, data);
        
        updateUIWithResults(state.analysisResult);
    }
    
    function calculateMetrics(signal, psd, freqs, fs, rawData) {
        const N = signal.length;
        let peakPower = 0, peakFreq = 0, peakIdx = -1;
        for (let i = 0; i < psd.length; i++) {
            if (freqs[i] >= 2 && freqs[i] <= 25 && psd[i] > peakPower) {
                 peakPower = psd[i]; peakFreq = freqs[i]; peakIdx = i;
            }
        }
        if (peakIdx === -1) throw new Error("Não foi possível encontrar um pico de frequência válido.");

        const totalPower = psd.reduce((sum, p) => sum + p, 1e-12);
        const rms = Math.sqrt(signal.reduce((sum, v) => sum + v**2, 0) / N);
        
        const halfMax = peakPower / 2;
        let lowerIdx = peakIdx, upperIdx = peakIdx;
        while (lowerIdx > 0 && psd[lowerIdx] > halfMax) lowerIdx--;
        while (upperIdx < psd.length - 1 && psd[upperIdx] > halfMax) upperIdx++;
        const fwhm = freqs[upperIdx] - freqs[lowerIdx];
        
        const searchRange = Math.min(peakIdx, psd.length - peakIdx - 1);
        let minPowerAroundPeak = peakPower;
        for(let i=1; i < Math.min(searchRange, 10); i++){ // Search in a small local range
            minPowerAroundPeak = Math.min(minPowerAroundPeak, psd[peakIdx - i], psd[peakIdx + i]);
        }
        const prominence = 10 * Math.log10(peakPower / (minPowerAroundPeak + 1e-12));

        const tsi = peakFreq > 0 ? fwhm / peakFreq : 0;
        const normalizedPsd = psd.map(p => p / totalPower);
        const entropy = -normalizedPsd.reduce((sum, p) => sum + (p > 0 ? p * Math.log2(p) : 0), 0);
        
        const jerk = [];
        for (let i = 1; i < N; i++) jerk.push(Math.abs((signal[i] - signal[i - 1]) / (1 / fs)));
        jerk.sort((a,b) => a-b);
        const jr50 = jerk[Math.floor(jerk.length / 2)] || 0;

        const waveletIndex = calculateWaveletEnergyRatio(signal, fs, peakFreq);

        return { 
            psd, freqs, peakFreq, totalPower, prominence, fwhm, tsi, entropy, rms, jr50, waveletIndex,
            timeSignal: { t: Array.from({length: N}, (_, i) => i / fs), y: signal },
            rawSignal: rawData,
            fs
        };
    }
    
    // --- UI Update with Results ---
    function updateUIWithResults(result) {
        const format = (val, dec = 2) => (typeof val === 'number' && !isNaN(val)) ? val.toFixed(dec) : '—';
        
        dom.metricPeakFreq.innerHTML = `${format(result.peakFreq, 1)} Hz`;
        dom.metricTotalPower.innerHTML = result.totalPower.toExponential(1);
        dom.metricProminence.innerHTML = `${format(result.prominence)} dB`;
        dom.metricFWHM.innerHTML = `${format(result.fwhm)} Hz`;
        dom.metricTSI.innerHTML = format(result.tsi, 2);
        dom.metricEntropy.innerHTML = format(result.entropy, 2);
        dom.metricRMS.innerHTML = format(result.rms, 2);
        dom.metricJR50.innerHTML = format(result.jr50, 1);
        dom.metricWavelet.innerHTML = format(result.waveletIndex, 2);

        classifyTremor(result);

        dom.resultsSection.classList.remove('hidden');
        dom.footerActions.classList.remove('hidden');
        updateStatus('ready', 'Análise concluída. Verifique os resultados.');
        
        renderCharts(result);

        if(window.innerWidth < 768) {
            dom.resultsSection.scrollIntoView({ behavior: 'smooth' });
        }
    }
    
    function classifyTremor({ peakFreq, tsi, prominence, totalPower, jr50, waveletIndex, fs }) {
        let scores = { OT: 0, ET: 0, DT: 0, MY: 0 };

        const prominenceFactor = Math.min(1, prominence / 20); // Normalized to ~20dB
        const stabilityFactor = Math.max(0, 1 - tsi * 2.5); // Punish high TSI
        const jerkFactor = Math.min(1, jr50 / (fs * 5 + 1e-9));

        if (peakFreq >= 4 && peakFreq <= 12) {
            scores.ET = (1 - Math.abs(peakFreq - 8) / 4) * stabilityFactor * prominenceFactor * waveletIndex;
        }
        if (peakFreq >= 13 && peakFreq <= 18) {
            scores.OT = (1 - Math.abs(peakFreq - 15.5) / 2.5) * Math.pow(stabilityFactor, 2) * Math.pow(prominenceFactor, 2) * waveletIndex;
        }

        const irregularityScore = (1 - stabilityFactor) + (1 - prominenceFactor) + jerkFactor;
        if (peakFreq >= 3 && peakFreq <= 9) {
            scores.DT = irregularityScore * 0.3 * (1 - waveletIndex);
        }
        scores.MY = irregularityScore * jerkFactor * 0.5;

        const total = Object.values(scores).reduce((a, b) => a + b, 1e-9);
        dom.classificationContainer.innerHTML = "";

        const sortedScores = Object.entries(scores).sort(([, a], [, b]) => b - a);
        if (total < 0.1) {
            dom.classificationContainer.innerHTML = `<div class="text-center text-gray-400">Padrão de tremor indeterminado ou sinal de baixa qualidade.</div>`;
            return;
        }

        for (const [type, score] of sortedScores) {
            const pct = (score / total) * 100;
            if (pct < 5) continue;

            const { label, color } = CLASSIFICATION_TYPES[type];
            const item = document.createElement("div");
            item.innerHTML = `
                <div class="flex justify-between items-center mb-1">
                    <span class="text-sm font-semibold" style="color: ${color};">${label}</span>
                    <span class="text-sm font-semibold text-white">${pct.toFixed(0)}%</span>
                </div>
                <div class="w-full bg-gray-700 rounded-full h-2">
                    <div class="h-2 rounded-full" style="width: ${pct}%; background-color: ${color};"></div>
                </div>`;
            dom.classificationContainer.appendChild(item);
        }
    }

    // --- Charting ---
    function renderCharts(result) {
        Chart.defaults.color = '#9ca3af';
        Chart.defaults.borderColor = '#4b5563';

        const timeCtx = document.getElementById('chartTime').getContext('2d');
        if(state.charts.time) state.charts.time.destroy();
        state.charts.time = new Chart(timeCtx, {
            type: 'line',
            data: {
                labels: result.timeSignal.t,
                datasets: [{
                    label: 'Amplitude',
                    data: result.timeSignal.y,
                    borderColor: '#60a5fa', borderWidth: 1, pointRadius: 0
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'Tempo (s)' } },
                    y: { title: { display: true, text: 'Amplitude' } }
                },
                plugins: { legend: { display: false } }
            }
        });
        
        const psdCtx = document.getElementById('chartPSD').getContext('2d');
        if(state.charts.psd) state.charts.psd.destroy();
        state.charts.psd = new Chart(psdCtx, {
            type: 'line',
            data: {
                labels: result.freqs,
                datasets: [{
                    label: 'Potência',
                    data: result.psd,
                    borderColor: '#f87171', backgroundColor: 'rgba(248, 113, 113, 0.2)',
                    borderWidth: 1.5, pointRadius: 0, fill: true
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                scales: {
                    x: { title: { display: true, text: 'Frequência (Hz)' }, max: 30 },
                    y: { type: 'logarithmic', title: { display: true, text: 'Potência (unidade²/Hz)' } }
                },
                plugins: { legend: { display: false } }
            }
        });
    }

    // --- Exporting ---
    async function exportPdf() {
        if (!state.analysisResult) return showToast('Nenhum resultado para exportar.', 'error');
        showToast('Gerando PDF, por favor aguarde...', 'info');
        
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF("p", "mm", "a4");
        const res = state.analysisResult;
        
        const margin = 15;
        const pageWidth = doc.internal.pageSize.getWidth();
        let currentY = 20;

        doc.setFont("helvetica", "bold").setFontSize(18).text("Relatório de Análise de Tremor - TremorPSD", pageWidth / 2, currentY, { align: "center" });
        currentY += 10;
        doc.setFont("helvetica", "normal").setFontSize(10).text(new Date().toLocaleString("pt-BR"), pageWidth / 2, currentY, { align: "center" });
        currentY += 15;

        doc.setFont("helvetica", "bold").setFontSize(14).text("Métricas Principais", margin, currentY);
        currentY += 8;
        doc.setFont("helvetica", "normal").setFontSize(11);
        
        const metricsCol1 = [
            `Freq. de Pico: ${res.peakFreq.toFixed(1)} Hz`,
            `Amplitude (RMS): ${res.rms.toFixed(2)}`,
            `Jerk (JR50): ${res.jr50.toFixed(1)}`,
            `FWHM: ${res.fwhm.toFixed(2)} Hz`
        ];
        const metricsCol2 = [
            `Potência Total: ${res.totalPower.toExponential(1)}`,
            `Proeminência: ${res.prominence.toFixed(1)} dB`,
            `Índice Wavelet: ${res.waveletIndex.toFixed(2)}`,
            `Estabilidade (TSI): ${res.tsi.toFixed(2)}`
        ];
        metricsCol1.forEach((text, i) => doc.text(text, margin, currentY + i * 7));
        metricsCol2.forEach((text, i) => doc.text(text, pageWidth / 2 + 5, currentY + i * 7));
        currentY += metricsCol1.length * 7 + 10;

        const timeCanvas = await html2canvas(document.getElementById('chartTime'));
        const psdCanvas = await html2canvas(document.getElementById('chartPSD'));
        const timeImgData = timeCanvas.toDataURL('image/png');
        const psdImgData = psdCanvas.toDataURL('image/png');
        const imgWidth = pageWidth - margin * 2;
        const imgHeight = (imgWidth * timeCanvas.height) / timeCanvas.width;

        doc.setFont("helvetica", "bold").setFontSize(12).text("Sinal no Domínio do Tempo", margin, currentY);
        currentY += 6;
        doc.addImage(timeImgData, 'PNG', margin, currentY, imgWidth, imgHeight);
        currentY += imgHeight + 8;
        
        doc.setFont("helvetica", "bold").setFontSize(12).text("Densidade Espectral de Potência (PSD)", margin, currentY);
        currentY += 6;
        doc.addImage(psdImgData, 'PNG', margin, currentY, imgWidth, imgHeight);

        doc.save(`TremorPSD_Relatorio_${Date.now()}.pdf`);
    }

    function createCsv(headers, rows) {
        let csvContent = "data:text/csv;charset=utf-8," + headers.join(',') + '\n';
        csvContent += rows.map(row => row.join(',')).join('\n');
        return encodeURI(csvContent);
    }
    
    function downloadCsv(csvContent, filename) {
        const link = document.createElement("a");
        link.setAttribute("href", csvContent);
        link.setAttribute("download", filename);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function exportMetricsCsv() {
        if (!state.analysisResult) return showToast('Nenhum resultado para exportar.', 'error');
        const res = state.analysisResult;
        const headers = ["Metrica", "Valor", "Unidade"];
        const rows = [
            ["Frequencia_Pico", res.peakFreq.toFixed(3), "Hz"],
            ["Potencia_Total", res.totalPower.toExponential(4), "unit^2"],
            ["Prominencia", res.prominence.toFixed(3), "dB"],
            ["FWHM", res.fwhm.toFixed(3), "Hz"],
            ["TSI", res.tsi.toFixed(4), ""],
            ["Entropia_Espectral", res.entropy.toFixed(4), ""],
            ["Amplitude_RMS", res.rms.toFixed(4), "unit"],
            ["Jerk_JR50", res.jr50.toFixed(3), "unit/s^3"],
            ["Indice_Wavelet", res.waveletIndex.toFixed(4), ""],
        ];
        downloadCsv(createCsv(headers, rows), `TremorPSD_Metricas_${Date.now()}.csv`);
    }

    function exportRawCsv() {
         if (!state.analysisResult || !state.analysisResult.rawSignal) return showToast('Nenhum resultado para exportar.', 'error');
         const data = state.analysisResult.rawSignal;
         const headers = ["timestamp_ms", "accel_x", "accel_y", "accel_z"];
         const rows = data.map(d => [d.t, d.x, d.y, d.z]);
         downloadCsv(createCsv(headers, rows), `TremorPSD_Dados_Brutos_${Date.now()}.csv`);
    }

    // --- Reset & Modals ---
    function resetApp() {
        resetResults();
        clearImported();
        updateStatus('ready');
    }
    
    function resetResults() {
        state.analysisResult = null;
        state.sensorData = [];
        if (state.charts.time) state.charts.time.destroy();
        if (state.charts.psd) state.charts.psd.destroy();
        dom.resultsSection.classList.add('hidden');
        dom.footerActions.classList.add('hidden');
        document.querySelectorAll('[id^="metric"]').forEach(m => m.textContent = '—');
        dom.classificationContainer.innerHTML = '';
    }
    
    function showInfoModal() { dom.infoModal.classList.remove('hidden'); }
    function hideInfoModal(event) { 
        if (!event || event.target.id === "infoModal") {
            dom.infoModal.classList.add('hidden');
        }
     }

    // --- DSP Functions ---
    function fft(real, imag) {
        const n = real.length;
        if (n === 0) return;
        // Bit-reversal permutation
        for (let i = 1, j = 0; i < n; i++) {
            let bit = n >> 1;
            for (; (j & bit) !== 0; bit >>= 1) j ^= bit;
            j ^= bit;
            if (i < j) {
                [real[i], real[j]] = [real[j], real[i]];
                [imag[i], imag[j]] = [imag[j], imag[i]];
            }
        }
        // Cooley-Tukey FFT
        for (let len = 2; len <= n; len <<= 1) {
            const halfLen = len >> 1;
            const angle = (-2 * Math.PI) / len;
            const w_real = Math.cos(angle);
            const w_imag = Math.sin(angle);
            for (let i = 0; i < n; i += len) {
                let t_real = 1, t_imag = 0;
                for (let j = 0; j < halfLen; j++) {
                    const u_real = real[i + j], u_imag = imag[i + j];
                    const v_real = real[i + j + halfLen] * t_real - imag[i + j + halfLen] * t_imag;
                    const v_imag = real[i + j + halfLen] * t_imag + imag[i + j + halfLen] * t_real;
                    real[i + j] = u_real + v_real;
                    imag[i + j] = u_imag + v_imag;
                    real[i + j + halfLen] = u_real - v_real;
                    imag[i + j + halfLen] = u_imag - v_imag;
                    [t_real, t_imag] = [t_real * w_real - t_imag * w_imag, t_real * w_imag + t_imag * w_real];
                }
            }
        }
    }

    function welch(signal, fs, nperseg) {
      const n = signal.length;
      nperseg = Math.min(nperseg, n);
      const noverlap = Math.floor(nperseg / 2);
      const step = nperseg - noverlap;
      const win = Array.from({length: nperseg}, (_, i) => 0.5 * (1 - Math.cos((2 * Math.PI * i) / (nperseg - 1))));
      const scale = 1.0 / (fs * (win.reduce((a, b) => a + b * b, 0)));
      let psd = new Float64Array(Math.floor(nperseg / 2) + 1).fill(0);
      let numSegments = 0;

      for (let i = 0; i + nperseg <= n; i += step) {
        const segment = signal.slice(i, i + nperseg);
        let real = new Float64Array(nperseg);
        for (let j = 0; j < nperseg; j++) real[j] = segment[j] * win[j];
        let imag = new Float64Array(nperseg).fill(0);
        fft(real, imag);
        for (let j = 0; j < psd.length; j++) {
          const specVal = real[j] ** 2 + imag[j] ** 2;
          psd[j] += j > 0 && j < psd.length - 1 ? 2 * specVal : specVal;
        }
        numSegments++;
      }

      if (numSegments > 0) psd = psd.map((v) => v * scale / numSegments);
      const freqs = Array.from({length: psd.length}, (_, i) => (i * fs) / nperseg);
      return { freqs, psd };
    }
    
    function morletWavelet(length, frequency, sampleRate) {
        const real = new Float64Array(length);
        const sigma = length / (2 * Math.PI * (frequency / (sampleRate / length)) * 2.5);
        const halfLength = Math.floor(length / 2);

        for (let i = 0; i < length; i++) {
            const t = i - halfLength;
            const gaussian = Math.exp(-(t * t) / (2 * sigma * sigma));
            const angle = 2 * Math.PI * frequency * (t / sampleRate);
            real[i] = Math.cos(angle) * gaussian;
        }
        return { real };
    }

    function convolve(signal, waveletReal) {
        const signalLen = signal.length;
        const waveletLen = waveletReal.length;
        let maxEnergy = 0;

        for (let i = 0; i <= signalLen - waveletLen; i++) {
            let energy = 0;
            for (let j = 0; j < waveletLen; j++) {
                energy += signal[i + j] * waveletReal[j];
            }
            const currentEnergy = energy * energy;
            if (currentEnergy > maxEnergy) maxEnergy = currentEnergy;
        }
        return maxEnergy;
    }

    function calculateWaveletEnergyRatio(signal, fs, peakFreq) {
        if (peakFreq < 2 || !fs) return 0;
        const waveletLength = Math.min(signal.length, Math.floor(fs));

        const peakWav = morletWavelet(waveletLength, peakFreq, fs);
        const peakEnergy = convolve(signal, peakWav.real);

        const noiseFreq = peakFreq > 10 ? 5 : 15;
        const noiseWav = morletWavelet(waveletLength, noiseFreq, fs);
        const noiseEnergy = convolve(signal, noiseWav.real);

        return peakEnergy / (peakEnergy + noiseEnergy + 1e-9);
    }
  </script>
</body>
</html>
